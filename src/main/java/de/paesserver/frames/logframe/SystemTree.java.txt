package de.paesserver.frames.logframe;

import javax.swing.tree.MutableTreeNode;
import javax.swing.tree.TreeNode;
import java.util.Iterator;

public class SystemTree {
    public SystemTree() {
    }

    public static BodyMutableTreeNode systemNode;

    public static void add(BodyMutableTreeNode node) {
        insertionProgress(node);

        if(systemNode.children().hasMoreElements()){
            Iterator<TreeNode> treeNodeIterator = systemNode.children().asIterator();
            BodyMutableTreeNode iteratedTreeNode;
            while (treeNodeIterator.hasNext()){
                iteratedTreeNode = (BodyMutableTreeNode) treeNodeIterator.next();
                iteratedTreeNode.sortChildren();
            }
        }
    }

    private static void insertionProgress(BodyMutableTreeNode node){
        assert node.toString().length() != 0;
        node.setUserObject(node.toString());
        node.setAllowsChildren(true);

        BodyMutableTreeNode closestTreeNode = (BodyMutableTreeNode) getClosestNode(node);
        int differenceBetweenClosestNodeToNode = removeSystemAndClusterAndRingName(node.toString().replace(closestTreeNode.toString(),"").trim()).split(" ").length;

        //If direct child of this node super add method will be called
        //otherwise it will call itself recursive and crash
        if(closestTreeNode == systemNode && differenceBetweenClosestNodeToNode <= 1){
            systemNode.add(node);
            node.setParent(systemNode);
            return;
        }

        //If name is equal, old or imaginary data is present. -> replacing it
        if(node.toString().equals(closestTreeNode.toString())){
            closestTreeNode.body = (node).body;
            return;
        }

        //If difference between names is one, node is direct child
        //closest:  Floall QC-R b48-0 B 3
        //node:     Floall QC-R b48-0 B 3 a
        if(differenceBetweenClosestNodeToNode == 1){
            closestTreeNode.add(node);
            node.setParent(closestTreeNode);
            return;
        }

        //If difference is bigger you have to reconstruct a path

        String diffWithNewNodeFromClosestChild = node.toString().replace(closestTreeNode.toString(), "").replace(" Belt Cluster", "").trim().replace(" Ring", "").trim();
        if(diffWithNewNodeFromClosestChild.length() >= 2)
            diffWithNewNodeFromClosestChild = diffWithNewNodeFromClosestChild.substring(0,diffWithNewNodeFromClosestChild.length()-2).trim();

        int missingBodyCount = diffWithNewNodeFromClosestChild.split(" ").length;

        //Beginning filling tree with imaginary bodies to maintain structure
        //new node name has to beginn with first body missing:
        // found node: Floall QC-R b48-0 A A Belt Cluster 1
        //If no bodies are in there first body to be added: Floall QC-R b48-0 A
        //And then so on... Floall QC-R b48-0 A A

        for(int i = 0; i < missingBodyCount;i++){
            String imaginaryNodeBodyString = removeSystemAndClusterAndRingName(diffWithNewNodeFromClosestChild).split(" ")[0];
            String imaginaryNodeBodyName = closestTreeNode + " " + imaginaryNodeBodyString;
            BodyMutableTreeNode imaginaryNode = new BodyMutableTreeNode(new ImaginaryBody(imaginaryNodeBodyName));

            closestTreeNode.add(imaginaryNode);
            imaginaryNode.setParent(closestTreeNode);

            closestTreeNode = imaginaryNode;
            diffWithNewNodeFromClosestChild = node.toString().replace(closestTreeNode.toString(), "").replace(" Belt Cluster", "").trim().replace(" Ring", "").trim();
        }

        closestTreeNode.add(node);
        node.setParent(closestTreeNode);
    }

    public static MutableTreeNode getClosestNode(MutableTreeNode relativeNode){
        MutableTreeNode cloesestNode = systemNode;
        Iterator<? extends TreeNode> iterator = cloesestNode.children().asIterator();
        //Relativ:  Zejae PR-T b49-0 AB 4 c
        //Fehler:   Zejae PR-T b49-0 A
        //Correct:  Zejae PR-T b49-0

        String[] rNodeParts = removeSystemAndClusterAndRingName(relativeNode.toString()).split(" ");
        int depth = 0;

        while (iterator.hasNext()) {
            TreeNode itaredTreeNode = iterator.next();
            String[] iNodeParts = removeSystemAndClusterAndRingName(itaredTreeNode.toString()).split(" ");
            if(iNodeParts.length > depth && rNodeParts.length > depth && rNodeParts[depth].equals(iNodeParts[depth])){
                depth++;
                cloesestNode = (MutableTreeNode) itaredTreeNode;
                iterator = cloesestNode.children().asIterator();
            }
        }
        return cloesestNode;
    }



    public static String removeSystemAndClusterAndRingName(String string){
        return string.replace(systemNode.starSystem.starSystem,"").trim().replace("Belt Cluster ","").trim().trim().replace("Ring ","").trim();
    }
}